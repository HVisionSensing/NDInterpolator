//============================================================================
// Name        : example.cpp
// Author      : Marcel Rehberg
// For building and execution instructions see doc/html/index.html
//============================================================================

// This is an example that demonstrates the influence of the theta parameter
// It is a little hard to use because it expects grid files generated by the 
// writeChebGrids.m matlab scripts and the number of runs as a command line
// argument. I am compelled to keep it although it is not very usefull for
// understanding the interpolator.


#include <iostream>

// defines matrix/vector i/o functions and other utilities
#include "RBFInterpolators.hpp"
#include "MultiRBFInterpolators.hpp"

#include "exampleDefs.hpp"



int main(int argc, char *argv[]) {

  // ublas types are included via NDInterpolator.h
  namespace ublas = boost::numeric::ublas;

  // create interpolation grid by reading grid
  ublas::matrix<double,ublas::column_major> grid;
  
  unsigned N;
  ublas::vector<double> data;
  ublas::matrix<double,ublas::column_major> diffData;
  ublas::matrix<double, ublas::column_major> dataMulti;
  std::vector<ublas::matrix<double, ublas::column_major> > diffDataMulti;
    // create evaluation grid
  ublas::vector<double> lcE(2);
  ublas::vector<double> rcE(2);
  ublas::vector<unsigned> numOfPointsE(2);

  ublas::matrix<double, ublas::column_major> eval;
  unsigned NEval;

  // storage for true result values obtained by evaluating the function on the evauluation grid
  ublas::vector<double> res;
  ublas::vector<double> resDiff;
  ublas::vector<double> resDiff2;
  ublas::vector<double> resDiffM;

  // storage for interpolation results up to derivatives of second order

  ublas::vector<double> resIMulti;
  ublas::vector<double> resDiffIMulti;
  ublas::vector<double> resDiff2IMulti;
  ublas::vector<double> resDiffMIMulti;

  typedef NDInterpolator::MultiRBFInterpolatorPUH<NDInterpolator::GaussianRBF<double>,2, 1> interpTypeMulti;
  //typedef NDInterpolator::MultiRBFInterpolatorH<NDInterpolator::GaussianRBF<double> > interpTypeMulti;
  interpTypeMulti* multiPUHermiteRBF;
  //===========================================================================================

  ublas::matrix<double,ublas::column_major> error(atoi(argv[1]),4);

  std::stringstream fileString;

for (unsigned j=0; j<(unsigned) atoi(argv[1]);j++){
  std::cout << "starting " << j << std::endl;
  fileString.str("");
  fileString<<"ex2Grid"<<j<<".dat";
  grid= NDInterpolator::readMatrix<2>(fileString.str());
  
  // create interpolation data
  // Attention: different data structure for multi-dim output interpolators although
  // the function only has one output
  N = grid.size2();
  data.resize(N);
  diffData.resize(2, N);
  dataMulti.resize(1, N);
  diffDataMulti.resize(N);
  for (unsigned i = 0; i < N; i++) {
    data(i) = rosenbrock(ublas::column(grid, i));
    dataMulti(0, i) = data(i);
    
    diffData(0, i) = diffRosenbrock(ublas::column(grid, i), 1);
    diffData(1, i) = diffRosenbrock(ublas::column(grid, i), 2);
    diffDataMulti[i] = ublas::trans(ublas::subrange(diffData, 0, 2, i, i + 1));
  }
    
  lcE(0) = -1.4;
  lcE(1) = -0.4;
  rcE(0) = 1.9;
  rcE(1) = 2.9;
  numOfPointsE(0) = 35;
  numOfPointsE(1) = 35;
  eval = NDInterpolator::genRecGrid(lcE, rcE, numOfPointsE);

  NEval = numOfPointsE(0) * numOfPointsE(1);

  // storage for true result values obtained by evaluating the function on the evauluation grid
  res.resize(NEval);
  resDiff.resize(NEval);
  resDiff2.resize(NEval);
  resDiffM.resize(NEval);

  // storage for interpolation results up to derivatives of second order

  resIMulti.resize(NEval);
  resDiffIMulti.resize(NEval);
  resDiff2IMulti.resize(NEval);
  resDiffMIMulti.resize(NEval);

  //----------------------------------------------------------------------------
  // Everything prepared to create and evaluate the interpolator objects
  //----------------------------------------------------------------------------
  
  //  multiPUHermiteRBF= new interpTypeMulti(grid, dataMulti,diffDataMulti, 2.);
  multiPUHermiteRBF= new interpTypeMulti(grid, dataMulti,diffDataMulti, 1.5,50,.33);
  //multiPUHermiteRBF->optimizeScale();
  //  std::cout << multiPUHermiteRBF->getScale() << std::endl;
   

  //============================================================================================
  // EXCHANGE interpolators here
  // evaluate interpolation object
  // Uses (Multi)NDInterpolator to be able to reference the different interpolators
  //===========================================================================================



  // evaluation for all points in evaluation grid
  for (unsigned i = 0; i < NEval; i++) {
    res(i) = rosenbrock(ublas::column(eval, i));
    resIMulti(i) = multiPUHermiteRBF->eval(ublas::column(eval, i))(0);
  
    resDiff(i) = diffRosenbrock(ublas::column(eval, i), 1);
    resDiffIMulti(i)
      = multiPUHermiteRBF->evalDiff(ublas::column(eval, i), 1)(0);

    resDiff2(i) = diff2Rosenbrock(ublas::column(eval, i), 1, 1);
    resDiff2IMulti(i)
      = multiPUHermiteRBF->evalDiff2(ublas::column(eval, i), 1)(0);

    resDiffM(i) = diff2Rosenbrock(ublas::column(eval, i), 1, 2);
    resDiffMIMulti(i) = multiPUHermiteRBF->evalDiffMixed(ublas::column(eval, i), 2, 1)(0);
  }
 

  // output absolute error per point (multi Interpolators)

  error(j,0)= ublas::norm_1(res - resIMulti) / NEval;
  error(j,1)= ublas::norm_inf(res - resIMulti);

  error(j,2)= ublas::norm_1(resDiff2 - resDiff2IMulti) / NEval;
  error(j,3)= ublas::norm_inf(resDiff2 - resDiff2IMulti);
  delete multiPUHermiteRBF;
 } // for j
 
 NDInterpolator::writeMatrix(error,"thetaRes.dat");
 
 return 0;
}

